<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="http://jekyllrb.com" version="3.4.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2017-04-03T07:04:57+02:00</updated><id>http://localhost:4000/</id><title type="html">Mateusz Maciaszek</title><subtitle>This blog covers topics about many different computer science fields, mainly distributed and concurrent systems. Some day it will help me to escape from the simulation we live in (not sure how yet).
</subtitle><entry><title type="html">JustinDB - has got more than 700 commits!</title><link href="http://localhost:4000/dsp2017/2017/04/03/justindb-more-than-seven-hundred-commits.html" rel="alternate" type="text/html" title="JustinDB - has got more than 700 commits!" /><published>2017-04-03T05:10:17+02:00</published><updated>2017-04-03T05:10:17+02:00</updated><id>http://localhost:4000/dsp2017/2017/04/03/justindb-more-than-seven-hundred-commits</id><content type="html" xml:base="http://localhost:4000/dsp2017/2017/04/03/justindb-more-than-seven-hundred-commits.html">&lt;h3 id=&quot;next-goal-achieved-&quot;&gt;Next goal achieved 🎉&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/speedcom/JustinDB&quot;&gt;JustinDB&lt;/a&gt; is a project of mine which helps me to explore broad world of architectures of a databases system. With day of 23.04.2017 it passed &lt;strong&gt;5 months of continous work&lt;/strong&gt; during which I achieved many set goals. Project has now more than &lt;strong&gt;700 commits&lt;/strong&gt;, &lt;strong&gt;6 watches&lt;/strong&gt;, &lt;strong&gt;18 stars&lt;/strong&gt; and &lt;strong&gt;4 forks&lt;/strong&gt; - these numbers mean very much to me (somebody may think that what I do in my sparse time is interesting).&lt;/p&gt;

&lt;p&gt;The more I work on this project the more I realize how broad this topic actually is. DBMSs (Database Management Systems) are a critical components of modern computing and the result of decades of research in both industry and academia. Since they were among the earliest multi-user server systems to be developed thus pioneered many systems design techniques for scalability and relability (these days are concerns in many other contexts).&lt;/p&gt;

&lt;p&gt;Builiding by own such advanced conceptually product is very demanding. There has been relatively sparse coverage in the literature of the systems design issues that make a DBMS work. Sometimes official docs of arleady created databases are a source of thruth and used as points of reference, particulary when multiple alternative designs have been adopted by different groups. Just think about all the concepts: process models, storage system design, parallel architecture, transaction system, querry processor and optimizer (plus some utilities and typical shared components).&lt;/p&gt;

&lt;h3 id=&quot;summary-of-current-implementation&quot;&gt;Summary of current implementation&lt;/h3&gt;

&lt;p&gt;I will let myself to point out what I’ve achieved/what topics were touched during mentioned 5 months of active development.
If you still hadn’t a chance to get familiarize with JustinDB you can read my previous &lt;a href=&quot;http://speedcom.github.io/dsp2017/2017/03/14/justindb-modern-reactive-nosql-database.html&quot;&gt;post&lt;/a&gt; (it covers many concepts).&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;clustering - &lt;a href=&quot;https://github.com/speedcom/JustinDB&quot;&gt;JustinDB&lt;/a&gt; is able to horizontally scale; we can add up and remove nodes from cluster configuration during runtime (depens on the user traffics this allows better utilization of server power consumption)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;replica records - data is copied to N of nodes in the cluster (in order to achieve high availability); we are able to tune how many of replicas we want to read/write before we return result to client (N/R/W terminology).&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;records versioning - &lt;a href=&quot;https://github.com/speedcom/JustinDB&quot;&gt;JustinDB&lt;/a&gt; uses concept of Vector Clocks here&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;entropy replica solving&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;protocol&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;pluggable backends&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;serialization&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;performance tests&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;CI/code coverage&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;modularized project&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;logo&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;dockerizing/service discovery&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><summary type="html">Next goal achieved 🎉 JustinDB is a project of mine which helps me to explore broad world of architectures of a databases system. With day of 23.04.2017 it passed 5 months of continous work during which I achieved many set goals. Project has now more than 700 commits, 6 watches, 18 stars and 4 forks - these numbers mean very much to me (somebody may think that what I do in my sparse time is interesting).</summary></entry><entry><title type="html">iTermocil - divide and conquer your terminal like a PRO</title><link href="http://localhost:4000/dsp2017/hacks/2017/03/28/iTermocil-divide-and-conquer-your-terminal.html" rel="alternate" type="text/html" title="iTermocil - divide and conquer your terminal like a PRO" /><published>2017-03-28T16:20:17+02:00</published><updated>2017-03-28T16:20:17+02:00</updated><id>http://localhost:4000/dsp2017/hacks/2017/03/28/iTermocil%20-%20divide%20and%20conquer%20your%20terminal</id><content type="html" xml:base="http://localhost:4000/dsp2017/hacks/2017/03/28/iTermocil-divide-and-conquer-your-terminal.html">&lt;h3 id=&quot;itermocil&quot;&gt;iTermocil&lt;/h3&gt;
&lt;p&gt;Last week I’ve introduced to your very neat script called &lt;a href=&quot;http://speedcom.github.io/dsp2017/hacks/2017/03/20/z-move-around-catalogs-in-terminal-like-a-pro.html&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Z.sh&lt;/code&gt;&lt;/a&gt;. 💖 Next to it I consider &lt;a href=&quot;https://github.com/TomAnthony/itermocil&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;iTermocil&lt;/code&gt;&lt;/a&gt; as a perfect complement of your heavily used dev toolbox. 🔧&lt;/p&gt;

&lt;h4 id=&quot;what-is-it&quot;&gt;What is it?&lt;/h4&gt;
&lt;p&gt;As &lt;a href=&quot;https://github.com/TomAnthony/itermocil&quot;&gt;official documentation&lt;/a&gt; stands out it allows us to setup pre-configured layouts of windows and panes in iTerm2, having each open in a specified directory and execute specified commands.&lt;/p&gt;

&lt;p&gt;Correct. 👌&lt;/p&gt;

&lt;p&gt;As a developer we can relatively often deal with situations in which we open the same set of tools in terminal in order to run specific project we work on actively. Its a good occasion to automate such thing and this is what &lt;code class=&quot;highlighter-rouge&quot;&gt;iTermocil&lt;/code&gt; is perfect for. 👊&lt;/p&gt;

&lt;h3 id=&quot;how-do-i-use-it-with-justindb&quot;&gt;How do I use it with JustinDB?&lt;/h3&gt;
&lt;p&gt;Its worth to notice that JustinDB can be started in a cluster - in order to emulate real-world environment we can represent it on local machine as a pool of processes (single process represents node of cluster).&lt;/p&gt;

&lt;p&gt;I’ve preconfigured bunch of different iTermocil’s configs. Depends on how big I want to have custer (3 or 5 nodes most of the time) I start cluster bootstraping with dedicated configuration.&lt;/p&gt;

&lt;p&gt;I’m running:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;itermocil justin-cluster-5&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;itermocil jsutin-cluster-3&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Puff, magic happens here 💭. This is what I see after a while - working &lt;a href=&quot;https://github.com/speedcom/JustinDB&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;JustinDB&lt;/code&gt;&lt;/a&gt; cluster I can run tests against it.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../../../../itermocil.png&quot; alt=&quot;&quot; title=&quot;Cluster with different loaded backends&quot; /&gt;&lt;/p&gt;</content><author><name></name></author><summary type="html">iTermocil Last week I’ve introduced to your very neat script called Z.sh. 💖 Next to it I consider iTermocil as a perfect complement of your heavily used dev toolbox. 🔧</summary></entry><entry><title type="html">JustinDB - Pluggable persistent and in-memory storage engines</title><link href="http://localhost:4000/dsp2017/2017/03/24/justindb-support-for-pluggable-persistent-and-in-memory-storage-engines.html" rel="alternate" type="text/html" title="JustinDB - Pluggable persistent and in-memory storage engines" /><published>2017-03-24T14:10:17+01:00</published><updated>2017-03-24T14:10:17+01:00</updated><id>http://localhost:4000/dsp2017/2017/03/24/justindb-support-for-pluggable-persistent-and-in-memory-storage-engines</id><content type="html" xml:base="http://localhost:4000/dsp2017/2017/03/24/justindb-support-for-pluggable-persistent-and-in-memory-storage-engines.html">&lt;h3 id=&quot;preface&quot;&gt;Preface&lt;/h3&gt;
&lt;p&gt;JustinDB was built with a mind of a modular architecture that supports pluggable backends. It simply means that you can still use all its features along with different backends to support a variety of use cases.&lt;/p&gt;

&lt;h3 id=&quot;interface&quot;&gt;Interface&lt;/h3&gt;
&lt;p&gt;There is only on requirement that needs to be considered into account while implementing your own JustinDB’s storage backend - &lt;code class=&quot;highlighter-rouge&quot;&gt;PluggableStorageProtocol&lt;/code&gt; interface (you can find it &lt;a href=&quot;https://github.com/justin-db/JustinDB/blob/master/justin-core/src/main/scala/justin/db/storage/PluggableStorageProtocol.scala&quot;&gt;here&lt;/a&gt;). Its neat and simple because only defines two operations:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;GET&lt;/li&gt;
  &lt;li&gt;PUT&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;One for fetching data, another one for putting them into. Since they may cross the boundaries of our system in order make IO operations both adress asynchronicity.&lt;/p&gt;

&lt;h3 id=&quot;benefits-️&quot;&gt;Benefits ✴️&lt;/h3&gt;
&lt;p&gt;The main reason for designing a pluggable persistence component is to choose the storage engine best suited for an application’s access patterns.&lt;/p&gt;

&lt;p&gt;Currently there are two implementations of the interface that JustinDB can work with:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/justin-db/JustinDB/tree/master/justin-storage-in-mem&quot;&gt;in-memory&lt;/a&gt;: it has nature of cache&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/justin-db/JustinDB/tree/master/justin-storage-persistent&quot;&gt;persistent&lt;/a&gt; (big WIP though): this allows to infinitely store data&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For example, you can combine JustinDB with &lt;strong&gt;In-Memory module&lt;/strong&gt; to use it as a &lt;strong&gt;big data cache&lt;/strong&gt;.
Alternatively, you can setup another cluster that combines JustinDB with &lt;strong&gt;Persistent module&lt;/strong&gt; as a &lt;strong&gt;big data database&lt;/strong&gt;.
Last but not least we are even able to define storage module per cluster node so that some of them can act as a cache and others like typical database.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../../../../justin-cache-persistent.png&quot; alt=&quot;&quot; title=&quot;Cluster with different loaded backends&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;how-engine-is-loaded-&quot;&gt;How engine is loaded 🔥&lt;/h4&gt;

&lt;p&gt;It uses reflection:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;object JustinDriver {

  def load(clazz: String): PluggableStorageProtocol = Class.forName(clazz)
    .newInstance()
    .asInstanceOf[PluggableStorageProtocol]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Exemplary usage taken from project (can be found &lt;a href=&quot;https://github.com/justin-db/JustinDB/blob/master/justin-http-api/src/main/scala/justin/http_api/Main.scala#L35&quot;&gt;here&lt;/a&gt;):&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;val storage = JustinDriver.load(config.getString(&quot;justin-db.storage&quot;))
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;It just reads path to implementation of &lt;code class=&quot;highlighter-rouge&quot;&gt;PluggableStorageProtocol&lt;/code&gt; interface from project’s &lt;code class=&quot;highlighter-rouge&quot;&gt;config&lt;/code&gt; value e.g. &lt;code class=&quot;highlighter-rouge&quot;&gt;justin.db.storage.InMemStorage&lt;/code&gt;&lt;/p&gt;</content><author><name></name></author><summary type="html">Preface JustinDB was built with a mind of a modular architecture that supports pluggable backends. It simply means that you can still use all its features along with different backends to support a variety of use cases.</summary></entry><entry><title type="html">Z.sh - move around catalogs in terminal like a PRO</title><link href="http://localhost:4000/dsp2017/hacks/2017/03/20/z-move-around-catalogs-in-terminal-like-a-pro.html" rel="alternate" type="text/html" title="Z.sh - move around catalogs in terminal like a PRO" /><published>2017-03-20T14:15:17+01:00</published><updated>2017-03-20T14:15:17+01:00</updated><id>http://localhost:4000/dsp2017/hacks/2017/03/20/z-move-around-catalogs-in-terminal-like-a-pro</id><content type="html" xml:base="http://localhost:4000/dsp2017/hacks/2017/03/20/z-move-around-catalogs-in-terminal-like-a-pro.html">&lt;h3 id=&quot;eureka&quot;&gt;Eureka&lt;/h3&gt;
&lt;p&gt;Have you ever get to known something that is simply brilliant and you feel that you were living without it way too long?&lt;/p&gt;

&lt;p&gt;Yes, I’ve got. I’ve found &lt;code class=&quot;highlighter-rouge&quot;&gt;z.sh&lt;/code&gt; script &lt;a href=&quot;https://github.com/rupa/z&quot;&gt;link&lt;/a&gt;. Its magic. Its simple. Its fantastic! 💖&lt;/p&gt;

&lt;h4 id=&quot;whats-it-is&quot;&gt;Whats it is&lt;/h4&gt;
&lt;p&gt;Its the script that tracks your most used directories, based on ‘frecency’. From README we can read that
“After  a  short  learning  phase, z will take you to the most ‘frecent’ directory that matches ALL of the regexes given on the command line, in order.”&lt;/p&gt;

&lt;p&gt;I was used to spend a lot of time to find appropriate catalog in terminal. To make it simpler I was adding more and more path aliases to shell config. That sounds like sth that could be improved.&lt;/p&gt;

&lt;h4 id=&quot;how-to-use-it&quot;&gt;How to use it&lt;/h4&gt;
&lt;p&gt;How &lt;code class=&quot;highlighter-rouge&quot;&gt;z.sh&lt;/code&gt; help here? To make it easier to visualize, as an example, lets take &lt;code class=&quot;highlighter-rouge&quot;&gt;Dropbox&lt;/code&gt; catalog into account. Its placed under &lt;code class=&quot;highlighter-rouge&quot;&gt;/Users/new/Dropbox&lt;/code&gt; path on my computer.
Now, when &lt;code class=&quot;highlighter-rouge&quot;&gt;z.sh&lt;/code&gt; has already registered Dropbox catalog’s path I am not forced to think about it anymore (you need to cd there at least once because z.sh does not scan your disk). I’m typing simple &lt;code class=&quot;highlighter-rouge&quot;&gt;z dropbox&lt;/code&gt; command and… I’m getting moved there correctly. I can even use shorter version like &lt;code class=&quot;highlighter-rouge&quot;&gt;z drop&lt;/code&gt; and it still works (&lt;code class=&quot;highlighter-rouge&quot;&gt;z.sh&lt;/code&gt; script uses regexp for finding matches). If &lt;code class=&quot;highlighter-rouge&quot;&gt;z.sh&lt;/code&gt; didn’t find any matches it simply leave you in current directory. While typing your command you can use tabulator which will unfold your regexp into path that script is thinking you want to move.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../../../../zscript.gif&quot; alt=&quot;&quot; title=&quot;Z.sh exemplary usage&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;how-to-install-it&quot;&gt;How to install it&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;Person who uses &lt;code class=&quot;highlighter-rouge&quot;&gt;oh-my-zsh&lt;/code&gt;.
    &lt;ol&gt;
      &lt;li&gt;You probably have already downloaded and having placed under &lt;code class=&quot;highlighter-rouge&quot;&gt;~/.oh-my-zsh/plugins/&lt;/code&gt; path.&lt;/li&gt;
      &lt;li&gt;In order to enabled it open &lt;code class=&quot;highlighter-rouge&quot;&gt;.zshrc&lt;/code&gt; file, find &lt;code class=&quot;highlighter-rouge&quot;&gt;plugins&lt;/code&gt; section and add name of the plugin (which is &lt;code class=&quot;highlighter-rouge&quot;&gt;z&lt;/code&gt;, hah). In my config this looks like: &lt;code class=&quot;highlighter-rouge&quot;&gt;plugins=(git, git-extras, z)&lt;/code&gt;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;Others (copy-pasted from README)
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Installation:
    Put something like this in your $HOME/.bashrc or $HOME/.zshrc:
           . /path/to/z.sh
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
    &lt;p&gt;Now try to cd around for a while to build up the db. You will be amazed by simplicity and usability of it.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Cheers and don’t thank me 👍&lt;/p&gt;</content><author><name></name></author><summary type="html">Eureka Have you ever get to known something that is simply brilliant and you feel that you were living without it way too long?</summary></entry><entry><title type="html">JustinDB - Database Model</title><link href="http://localhost:4000/dsp2017/2017/03/17/justindb-database-model.html" rel="alternate" type="text/html" title="JustinDB - Database Model" /><published>2017-03-17T17:09:17+01:00</published><updated>2017-03-17T17:09:17+01:00</updated><id>http://localhost:4000/dsp2017/2017/03/17/justindb-database-model</id><content type="html" xml:base="http://localhost:4000/dsp2017/2017/03/17/justindb-database-model.html">&lt;h3 id=&quot;database-models&quot;&gt;Database models&lt;/h3&gt;
&lt;p&gt;Althought there are &lt;a href=&quot;http://nosql-database.org/&quot;&gt;numerous&lt;/a&gt; differents NoSQL databases we can group them the ways they represent logical data. This characteristic is the answer that arose to specific problems not originally envisioned by the relational counterparts.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Note: Be mind that the following models can be mixed together (e.g. key-value model built on top of relational DB)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;1. Key/Value:&lt;/strong&gt;
They are conceptually like hashtables where values are stored and accessed by immutable key. Such products usually offer relatively simple interface we work against with; more complex queries are often deprecated.
&lt;a href=&quot;https://github.com/speedcom/JustinDB&quot;&gt;JustinDB&lt;/a&gt; along with e.g. &lt;code class=&quot;highlighter-rouge&quot;&gt;Riak&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;Redis&lt;/code&gt; are exemplary products of such.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2. Columnar:&lt;/strong&gt;
Its goal is to group similiar data into column families. They often characterizes itself with very good write throughput.
One of the most popular actively used database here is &lt;code class=&quot;highlighter-rouge&quot;&gt;Apache Cassandra&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3. Document:&lt;/strong&gt;
These kind of datbases does not enforce a document schema. They owe their name because of storing hierarchical values called documents. Examples: &lt;code class=&quot;highlighter-rouge&quot;&gt;MongoDB&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;CouchDB&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4. Graph:&lt;/strong&gt;
They are very good for modeling complex relationship between nodes e.g. friends (lets think about social media sites like Facebook or LinkedIn). Examples: &lt;code class=&quot;highlighter-rouge&quot;&gt;Neo4j, OrientDB&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&quot;justindb-database-model&quot;&gt;JustinDB database model&lt;/h4&gt;
&lt;p&gt;Choosing logical model is a very important part at a time of architecture modeling.&lt;/p&gt;

&lt;p&gt;I’ve decided to make JustinDB key-value oriented database. Reasoning was simple:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;we all intuitively know how key-value data structure works (think about e.g. &lt;code class=&quot;highlighter-rouge&quot;&gt;HashMap&lt;/code&gt;)&lt;/li&gt;
  &lt;li&gt;I wasn’t forced to think about implementation of Query Planner (thing that translate complex queries (e.g. SQL query) into understandable structures by db engine against which it gets appropriate data)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;That way I was able to implement more interesting parts to me of distributed databases. Whats more important its broadly used model so there are many available docs we can read.&lt;/p&gt;

&lt;p&gt;Making such a decision has an important tradeoffs and impact how we design the rest of the system:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;how do we query complex set of data?&lt;/li&gt;
  &lt;li&gt;how do we replicate data and spread them (do partitioning actually) across the cluster?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Trying to get answers is the real challenge and whole fun is starting exactly here. 👍&lt;/p&gt;

&lt;h4 id=&quot;when-using-keyvalue-store-make-sense&quot;&gt;When using key/value store make sense&lt;/h4&gt;
&lt;p&gt;Databases such as JustinDB almost always performs best when you build your application around basic CRUD application (create, read, update, and delete) on objects.&lt;/p&gt;

&lt;p&gt;JustinDB’s key/value architecture enables it to be more performant than relational databases in many scenarios because it doesn’t need to perform lock, union, join, or other operations when working with objects. Instead, it interacts with objects on a one-by-one basis, using primary key lookups.&lt;/p&gt;

&lt;h4 id=&quot;when-using-keyvalue-store-is-less-of-a-good-fit&quot;&gt;When using key/value store is less of a good fit&lt;/h4&gt;
&lt;p&gt;If you application demands a high query load by any means other than key/value lookup e.g. SQL-style &lt;code class=&quot;highlighter-rouge&quot;&gt;SELECT * FROM table&lt;/code&gt; operations - JustinDB will not be as efficient as other databases. Other thing, so to speak, JustinDB’s simple data model means that your data must be denormalized if your system is to be reasonably performant.&lt;/p&gt;

&lt;h3 id=&quot;summary&quot;&gt;Summary&lt;/h3&gt;
&lt;p&gt;Making decision about chosing key/value logical model was one of the most important part while architecting my own NoSQL database. Since its relatively easy concept to wrap head around it could help me to move faster to other fancy “distributed” stuff. 💎&lt;/p&gt;</content><author><name></name></author><summary type="html">Database models Althought there are numerous differents NoSQL databases we can group them the ways they represent logical data. This characteristic is the answer that arose to specific problems not originally envisioned by the relational counterparts.</summary></entry><entry><title type="html">JustinDB - Modern REACTIVE NoSQL database</title><link href="http://localhost:4000/dsp2017/2017/03/14/justindb-modern-reactive-nosql-database.html" rel="alternate" type="text/html" title="JustinDB - Modern REACTIVE NoSQL database" /><published>2017-03-14T07:29:17+01:00</published><updated>2017-03-14T07:29:17+01:00</updated><id>http://localhost:4000/dsp2017/2017/03/14/justindb-modern-reactive-nosql-database</id><content type="html" xml:base="http://localhost:4000/dsp2017/2017/03/14/justindb-modern-reactive-nosql-database.html">&lt;h3 id=&quot;what-is-this-all-about&quot;&gt;What is this all about&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://www.wikiwand.com/en/NoSQL&quot;&gt;NoSQL&lt;/a&gt; term was coined a decade ago. We have on market at least a dozen of different NoSQL databases with specific data model. They are so popular that many of engineers are not afraid to take them as a tool of first choice while bootsraping a new project.&lt;/p&gt;

&lt;p&gt;Its tend to think that they are “scalable out of the box product” - lets assume thats true. But…&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;What exactly causes it?&lt;/li&gt;
  &lt;li&gt;What kind of algorithms and data structures are used in place?&lt;/li&gt;
  &lt;li&gt;What trade-off database engineers are need to deal with?&lt;/li&gt;
  &lt;li&gt;What makes that they are so-said scalable?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;These are the questions we are going to answer through a couple of next posts. 🤔&lt;/p&gt;

&lt;h3 id=&quot;why-yet-another-database&quot;&gt;Why yet another database&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/speedcom/JustinDB&quot;&gt;JustinDB&lt;/a&gt; is an attempt to write my own distributed database. Its mainly educational goal. This project is far from being production ready in mind (such non-travial things are built over several years). Since its a complete writing from scratch I was happy to make it the way I would like - I was the one who decided what  algorithms, data structures and architecture will be. Being frankly, at current point JustinDB is a pretty faithfull implementation of &lt;a href=&quot;http://www.allthingsdistributed.com/files/amazon-dynamo-sosp2007.pdf&quot;&gt;whitepaper&lt;/a&gt; written by Amazon research team describing architecture of DynamoDB database (they prominent product used actively over decade in AWS).&lt;/p&gt;

&lt;p&gt;Lets sum up main characteristic of &lt;a href=&quot;https://github.com/speedcom/JustinDB&quot;&gt;JustinDB&lt;/a&gt; (these will be covered more extensively in next posts):&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;key-value model:
every single value written to database has its uniqe own key across the whole database (cluster as well); database is value type agnostic which simply mean it can store e.g. strings, numbers and even binaries&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;high-availablity:
this trait is naturraly welcome when we want to have solution that works possibly all the time; when one node of the cluster’s node is not available during job processing then rest of them takes care of it&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;partitioning:
data is split across the cluster by using technique called Consistent Hashing (JustinDB uses its modified version); it simply deducts what node of the cluster should store the pushed data and which node should be asked in order to get particular data by its key&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;replication:
having splitted data across the cluster is not sufficient when we want to achieve high-availability; data needs to be copied to a couple of distinct nodes&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;data multi-versioning:
there are the cases when client wants to update its data; in distributed system its highly possible scenario that while updating specific record node with desired replica is not available so we can’t update it to the newest version; we should follow such situations in order to not override our data with older versions (nobody wants stales reads); to achieve that JustinDB uses Vector Clocks, CRDTs and different levels of fightining against data entropy e.g. Active-Anti Entropy and Merkle Trees (its used e.g. in Bitcoin)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;concurrency:
whole architecture is built on top of Actor Model - it greatly simplify modeling of concurrent operations&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.wikiwand.com/en/CAP_theorem&quot;&gt;CAP theorem&lt;/a&gt;:
from perspective of this theorem JustinDB was designed to be AP system - highy available (A) and partition tolerant (P) and the same time. This was achieved by bringing relaxed model of data (so called Eventual Consistency).&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;stack:
database is entirely written in Scala using Akka library (e.g. its Cluster module); Admin UI is written using Elm language (still in progress though)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;aaand last part…&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;reactivness:
What does it mean? Is this sth that other databases don’t have? From official site of &lt;a href=&quot;http://www.reactivemanifesto.org&quot;&gt;manifesto&lt;/a&gt; we can read that characteristic of such systems are: responsivness, resiliency, elasticity, message driven approach. JustinDB has (or try to have) all of it. Its very broad topic we will cover in one of the next post.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;summary&quot;&gt;Summary&lt;/h3&gt;
&lt;p&gt;JustinDB is relatively young project which still lack of many welcome features (some of them are in progress, some not even started). Its OOS so its really welcome to have contributors - I think that this topic can be very interesting to many of you.&lt;/p&gt;

&lt;p&gt;You can find an official JustinDB respository &lt;a href=&quot;https://github.com/speedcom/JustinDB&quot;&gt;here&lt;/a&gt;. 💪&lt;/p&gt;

&lt;p&gt;In next post we are going to cover one of the above point more extensively looking closer how exactly NoSQL databases work and how JustinDB solely solves it. 👍&lt;/p&gt;</content><author><name></name></author><summary type="html">What is this all about NoSQL term was coined a decade ago. We have on market at least a dozen of different NoSQL databases with specific data model. They are so popular that many of engineers are not afraid to take them as a tool of first choice while bootsraping a new project.</summary></entry><entry><title type="html">Get noticed!</title><link href="http://localhost:4000/dsp2017/2017/03/12/get-noticed.html" rel="alternate" type="text/html" title="Get noticed!" /><published>2017-03-12T16:55:17+01:00</published><updated>2017-03-12T16:55:17+01:00</updated><id>http://localhost:4000/dsp2017/2017/03/12/get-noticed</id><content type="html" xml:base="http://localhost:4000/dsp2017/2017/03/12/get-noticed.html">&lt;p&gt;Hello there! How are you? 😊&lt;/p&gt;

&lt;p&gt;I’m Mateusz and welcome on my homepage. This whole blog is a result of polish initiative called &lt;a href=&quot;http://devstyle.pl/daj-sie-poznac/&quot;&gt;Get noticed!&lt;/a&gt; in which you write a bunch of posts every single week and create OSS project till end of May 2017. Its goal is to motivate every person who want to actively blog but never really started do that. 👍&lt;/p&gt;

&lt;p&gt;In the couple of next weeks I’m going to cover how exactly I’ve built (still building btw) &lt;a href=&quot;https://github.com/speedcom/JustinDB&quot;&gt;JustinDB&lt;/a&gt; which is actually a faiful implementation of Amazon DynamoDB specification (the one that was inspiration for modern NoSQL databases) with some exceptions. 🔥&lt;/p&gt;</content><author><name></name></author><summary type="html">Hello there! How are you? 😊</summary></entry></feed>